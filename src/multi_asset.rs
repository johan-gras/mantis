//! Multi-asset portfolio backtesting support.
//!
//! This module enables backtesting strategies across multiple assets simultaneously,
//! supporting portfolio-level risk management and rebalancing.
//!
//! # Example
//!
//! ```ignore
//! use mantis::multi_asset::{MultiAssetEngine, PortfolioStrategy, AllocationSignal};
//! use mantis::engine::BacktestConfig;
//!
//! let config = BacktestConfig::default();
//! let mut engine = MultiAssetEngine::new(config);
//!
//! engine.add_data("AAPL", aapl_bars);
//! engine.add_data("GOOG", goog_bars);
//!
//! let result = engine.run(&mut strategy)?;
//! ```

use crate::data::DataManager;
use crate::engine::BacktestConfig;
use crate::error::{BacktestError, Result};
use crate::portfolio::Portfolio;
use crate::types::{Bar, EquityPoint, Order, Side, Trade};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::{BTreeMap, HashMap};
use tracing::info;

/// Target allocation for an asset as a fraction of portfolio.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct Allocation {
    /// Target weight (0.0 to 1.0).
    pub weight: f64,
    /// Minimum weight (optional floor).
    pub min_weight: f64,
    /// Maximum weight (optional cap).
    pub max_weight: f64,
}

impl Allocation {
    /// Create a new allocation with target weight.
    pub fn new(weight: f64) -> Self {
        Self {
            weight: weight.clamp(0.0, 1.0),
            min_weight: 0.0,
            max_weight: 1.0,
        }
    }

    /// Create allocation with bounds.
    pub fn with_bounds(weight: f64, min: f64, max: f64) -> Self {
        Self {
            weight: weight.clamp(min, max),
            min_weight: min,
            max_weight: max,
        }
    }
}

/// Signal generated by a portfolio strategy.
#[derive(Debug, Clone)]
pub enum AllocationSignal {
    /// Target allocations for all assets.
    Allocate(HashMap<String, Allocation>),
    /// Rebalance to specified weights.
    Rebalance(HashMap<String, f64>),
    /// Exit all positions.
    ExitAll,
    /// No change.
    Hold,
}

/// Context for portfolio strategy decisions.
#[derive(Debug)]
pub struct PortfolioContext<'a> {
    /// Current bar index.
    pub bar_index: usize,
    /// Current bars for all symbols.
    pub current_bars: &'a HashMap<String, Bar>,
    /// Historical bars for all symbols.
    pub bars: &'a HashMap<String, Vec<Bar>>,
    /// Current positions (symbol -> quantity).
    pub positions: HashMap<String, f64>,
    /// Current cash.
    pub cash: f64,
    /// Total portfolio equity.
    pub equity: f64,
    /// Current weights of each position.
    pub weights: HashMap<String, f64>,
    /// Symbols being traded.
    pub symbols: &'a [String],
}

impl<'a> PortfolioContext<'a> {
    /// Get current price for a symbol.
    pub fn price(&self, symbol: &str) -> Option<f64> {
        self.current_bars.get(symbol).map(|b| b.close)
    }

    /// Get historical bars for a symbol.
    pub fn history(&self, symbol: &str) -> Option<&Vec<Bar>> {
        self.bars.get(symbol)
    }

    /// Get current weight of a symbol.
    pub fn weight(&self, symbol: &str) -> f64 {
        self.weights.get(symbol).copied().unwrap_or(0.0)
    }

    /// Check if we have a position in a symbol.
    pub fn has_position(&self, symbol: &str) -> bool {
        self.positions.get(symbol).is_some_and(|&q| q.abs() > 0.0)
    }

    /// Calculate correlation between two symbols over a lookback period.
    pub fn correlation(&self, symbol1: &str, symbol2: &str, lookback: usize) -> Option<f64> {
        let bars1 = self.bars.get(symbol1)?;
        let bars2 = self.bars.get(symbol2)?;

        if bars1.len() < lookback || bars2.len() < lookback {
            return None;
        }

        let returns1: Vec<f64> = bars1[bars1.len() - lookback..]
            .windows(2)
            .map(|w| (w[1].close - w[0].close) / w[0].close)
            .collect();

        let returns2: Vec<f64> = bars2[bars2.len() - lookback..]
            .windows(2)
            .map(|w| (w[1].close - w[0].close) / w[0].close)
            .collect();

        if returns1.len() != returns2.len() || returns1.is_empty() {
            return None;
        }

        let mean1: f64 = returns1.iter().sum::<f64>() / returns1.len() as f64;
        let mean2: f64 = returns2.iter().sum::<f64>() / returns2.len() as f64;

        let cov: f64 = returns1
            .iter()
            .zip(returns2.iter())
            .map(|(r1, r2)| (r1 - mean1) * (r2 - mean2))
            .sum::<f64>()
            / returns1.len() as f64;

        let std1: f64 = (returns1.iter().map(|r| (r - mean1).powi(2)).sum::<f64>()
            / returns1.len() as f64)
            .sqrt();
        let std2: f64 = (returns2.iter().map(|r| (r - mean2).powi(2)).sum::<f64>()
            / returns2.len() as f64)
            .sqrt();

        if std1 > 0.0 && std2 > 0.0 {
            Some(cov / (std1 * std2))
        } else {
            None
        }
    }

    /// Calculate the percentile rank of a symbol's metric across the universe.
    ///
    /// Returns a value between 0.0 (lowest) and 1.0 (highest) indicating where
    /// the symbol ranks relative to all other symbols for the given metric.
    ///
    /// # Arguments
    /// * `symbol` - The symbol to rank
    /// * `metric_fn` - Function that computes the metric from historical bars
    /// * `lookback` - Minimum number of bars required for metric calculation
    ///
    /// # Example
    /// ```ignore
    /// // Rank by momentum (return over last 20 bars)
    /// let momentum_rank = ctx.rank_percentile("AAPL", |bars, lb| {
    ///     if bars.len() < lb { return None; }
    ///     let start = bars[bars.len() - lb].close;
    ///     let end = bars.last().unwrap().close;
    ///     Some((end - start) / start)
    /// }, 20);
    /// ```
    pub fn rank_percentile<F>(&self, symbol: &str, metric_fn: F, lookback: usize) -> Option<f64>
    where
        F: Fn(&Vec<Bar>, usize) -> Option<f64>,
    {
        // Calculate metric for target symbol
        let target_bars = self.bars.get(symbol)?;
        let target_value = metric_fn(target_bars, lookback)?;

        // Calculate metric for all symbols in universe
        let mut values: Vec<(String, f64)> = Vec::new();
        for sym in self.symbols {
            if let Some(bars) = self.bars.get(sym) {
                if let Some(value) = metric_fn(bars, lookback) {
                    values.push((sym.clone(), value));
                }
            }
        }

        if values.len() < 2 {
            return None; // Need at least 2 symbols for meaningful ranking
        }

        // Count how many symbols have lower values
        let lower_count = values.iter().filter(|(_, v)| *v < target_value).count();

        // Percentile rank = (number below + 0.5 * number equal) / total
        // Simplified: number below / (total - 1) for unique values
        let percentile = lower_count as f64 / (values.len() - 1) as f64;

        Some(percentile)
    }

    /// Calculate the cross-sectional z-score of a symbol's metric across the universe.
    ///
    /// Returns how many standard deviations the symbol's metric is from the
    /// universe mean. Positive values indicate above-average, negative below-average.
    ///
    /// # Arguments
    /// * `symbol` - The symbol to score
    /// * `metric_fn` - Function that computes the metric from historical bars
    /// * `lookback` - Minimum number of bars required for metric calculation
    ///
    /// # Example
    /// ```ignore
    /// // Z-score by volatility (std dev of returns over last 20 bars)
    /// let vol_zscore = ctx.cross_sectional_zscore("AAPL", |bars, lb| {
    ///     if bars.len() < lb { return None; }
    ///     let returns: Vec<f64> = bars[bars.len()-lb..].windows(2)
    ///         .map(|w| (w[1].close - w[0].close) / w[0].close).collect();
    ///     let mean = returns.iter().sum::<f64>() / returns.len() as f64;
    ///     let variance = returns.iter().map(|r| (r - mean).powi(2)).sum::<f64>() / returns.len() as f64;
    ///     Some(variance.sqrt())
    /// }, 20);
    /// ```
    pub fn cross_sectional_zscore<F>(
        &self,
        symbol: &str,
        metric_fn: F,
        lookback: usize,
    ) -> Option<f64>
    where
        F: Fn(&Vec<Bar>, usize) -> Option<f64>,
    {
        // Calculate metric for target symbol
        let target_bars = self.bars.get(symbol)?;
        let target_value = metric_fn(target_bars, lookback)?;

        // Calculate metric for all symbols in universe
        let mut values: Vec<f64> = Vec::new();
        for sym in self.symbols {
            if let Some(bars) = self.bars.get(sym) {
                if let Some(value) = metric_fn(bars, lookback) {
                    values.push(value);
                }
            }
        }

        if values.len() < 2 {
            return None; // Need at least 2 symbols for meaningful z-score
        }

        // Calculate mean and standard deviation across universe
        let mean = values.iter().sum::<f64>() / values.len() as f64;
        let variance =
            values.iter().map(|v| (v - mean).powi(2)).sum::<f64>() / values.len() as f64;
        let std_dev = variance.sqrt();

        if std_dev > 0.0 {
            Some((target_value - mean) / std_dev)
        } else {
            Some(0.0) // All values are the same
        }
    }

    /// Calculate relative momentum of a symbol compared to the universe average.
    ///
    /// Returns the momentum (return) of the symbol minus the equal-weighted
    /// average momentum of all symbols in the universe.
    ///
    /// # Arguments
    /// * `symbol` - The symbol to calculate relative momentum for
    /// * `lookback` - Number of bars to calculate momentum over
    ///
    /// # Returns
    /// Relative momentum as a decimal (e.g., 0.05 = 5% outperformance).
    /// Positive values indicate outperformance, negative underperformance.
    ///
    /// # Example
    /// ```ignore
    /// // Relative momentum over last 20 bars
    /// if let Some(rel_mom) = ctx.relative_momentum("AAPL", 20) {
    ///     if rel_mom > 0.0 {
    ///         println!("AAPL is outperforming the universe");
    ///     }
    /// }
    /// ```
    pub fn relative_momentum(&self, symbol: &str, lookback: usize) -> Option<f64> {
        // Calculate momentum for target symbol
        let target_bars = self.bars.get(symbol)?;
        if target_bars.len() < lookback + 1 {
            return None;
        }

        let start_price = target_bars[target_bars.len() - lookback - 1].close;
        let end_price = target_bars.last()?.close;
        let target_momentum = (end_price - start_price) / start_price;

        // Calculate average momentum across universe
        let mut momentums: Vec<f64> = Vec::new();
        for sym in self.symbols {
            if let Some(bars) = self.bars.get(sym) {
                if bars.len() >= lookback + 1 {
                    let start = bars[bars.len() - lookback - 1].close;
                    let end = bars.last()?.close;
                    let momentum = (end - start) / start;
                    momentums.push(momentum);
                }
            }
        }

        if momentums.is_empty() {
            return None;
        }

        let avg_momentum = momentums.iter().sum::<f64>() / momentums.len() as f64;
        let relative = target_momentum - avg_momentum;

        Some(relative)
    }

    /// Calculate the percentile rank of a symbol by a simple metric (price, volume, etc.).
    ///
    /// This is a convenience method for ranking by simple bar metrics without
    /// needing to provide a custom metric function.
    ///
    /// # Arguments
    /// * `symbol` - The symbol to rank
    /// * `metric` - The metric to rank by ("return", "volume", "volatility")
    /// * `lookback` - Number of bars for metric calculation
    ///
    /// # Returns
    /// Percentile rank from 0.0 (lowest) to 1.0 (highest), or None if insufficient data.
    pub fn rank_by_metric(&self, symbol: &str, metric: &str, lookback: usize) -> Option<f64> {
        match metric {
            "return" | "momentum" => self.rank_percentile(
                symbol,
                |bars, lb| {
                    if bars.len() < lb + 1 {
                        return None;
                    }
                    let start = bars[bars.len() - lb - 1].close;
                    let end = bars.last()?.close;
                    Some((end - start) / start)
                },
                lookback,
            ),
            "volume" => self.rank_percentile(
                symbol,
                |bars, lb| {
                    if bars.len() < lb {
                        return None;
                    }
                    let avg_vol =
                        bars[bars.len() - lb..].iter().map(|b| b.volume).sum::<f64>()
                            / lb as f64;
                    Some(avg_vol)
                },
                lookback,
            ),
            "volatility" => self.rank_percentile(
                symbol,
                |bars, lb| {
                    if bars.len() < lb + 1 {
                        return None;
                    }
                    let returns: Vec<f64> = bars[bars.len() - lb..]
                        .windows(2)
                        .map(|w| (w[1].close - w[0].close) / w[0].close)
                        .collect();
                    if returns.is_empty() {
                        return None;
                    }
                    let mean = returns.iter().sum::<f64>() / returns.len() as f64;
                    let variance = returns
                        .iter()
                        .map(|r| (r - mean).powi(2))
                        .sum::<f64>()
                        / returns.len() as f64;
                    Some(variance.sqrt())
                },
                lookback,
            ),
            _ => None,
        }
    }
}

/// Trait for multi-asset portfolio strategies.
pub trait PortfolioStrategy: Send + Sync {
    /// Returns the name of the strategy.
    fn name(&self) -> &str;

    /// Called once at the start of the backtest.
    fn init(&mut self) {}

    /// Generate allocation signals based on current state.
    fn on_bars(&mut self, ctx: &PortfolioContext) -> AllocationSignal;

    /// Called at the end of the backtest.
    fn on_finish(&mut self) {}

    /// Minimum bars needed before the strategy can generate signals.
    fn warmup_period(&self) -> usize {
        0
    }
}

/// Result from a multi-asset backtest.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MultiAssetResult {
    /// Strategy name.
    pub strategy_name: String,
    /// Symbols traded.
    pub symbols: Vec<String>,
    /// Initial capital.
    pub initial_capital: f64,
    /// Final equity.
    pub final_equity: f64,
    /// Total return percentage.
    pub total_return_pct: f64,
    /// Annual return percentage.
    pub annual_return_pct: f64,
    /// Maximum drawdown percentage.
    pub max_drawdown_pct: f64,
    /// Sharpe ratio.
    pub sharpe_ratio: f64,
    /// Sortino ratio.
    pub sortino_ratio: f64,
    /// Total trades across all assets.
    pub total_trades: usize,
    /// Trades by symbol.
    pub trades_by_symbol: HashMap<String, usize>,
    /// All trades.
    pub trades: Vec<Trade>,
    /// Equity curve.
    pub equity_curve: Vec<EquityPoint>,
    /// Start time.
    pub start_time: DateTime<Utc>,
    /// End time.
    pub end_time: DateTime<Utc>,
    /// Weight history (sampled).
    pub weight_history: Vec<(DateTime<Utc>, HashMap<String, f64>)>,
}

/// Multi-asset backtest engine.
pub struct MultiAssetEngine {
    config: BacktestConfig,
    data: DataManager,
}

impl MultiAssetEngine {
    /// Create a new multi-asset engine.
    pub fn new(config: BacktestConfig) -> Self {
        Self {
            config,
            data: DataManager::new(),
        }
    }

    /// Add data for a symbol.
    pub fn add_data(&mut self, symbol: impl Into<String>, bars: Vec<Bar>) {
        self.data.add(symbol, bars);
    }

    /// Run multi-asset backtest.
    pub fn run(&self, strategy: &mut dyn PortfolioStrategy) -> Result<MultiAssetResult> {
        let symbols: Vec<String> = self.data.symbols().iter().map(|s| s.to_string()).collect();

        if symbols.is_empty() {
            return Err(BacktestError::NoData);
        }

        // Find common date range
        let (min_len, start_time, end_time) = self.find_common_range(&symbols)?;

        info!(
            "Running multi-asset backtest: {} on {} symbols ({} bars)",
            strategy.name(),
            symbols.len(),
            min_len
        );

        strategy.init();

        let mut portfolio =
            Portfolio::with_cost_model(self.config.initial_capital, self.config.cost_model.clone());
        portfolio.allow_short = self.config.allow_short;
        portfolio.fractional_shares = self.config.fractional_shares;
        portfolio.set_execution_price(self.config.execution_price);
        portfolio.set_lot_selection_method(self.config.lot_selection.clone());
        portfolio.set_asset_configs(self.data.asset_configs());
        let volume_profiles = self.data.volume_profiles();
        portfolio.set_volume_profiles(&volume_profiles);

        let warmup = strategy.warmup_period();

        // Align data by date
        let aligned_data = self.align_data(&symbols)?;
        let timestamps: Vec<DateTime<Utc>> = aligned_data.keys().cloned().collect();

        let mut weight_history = Vec::new();
        let mut sample_interval = timestamps.len() / 100;
        if sample_interval == 0 {
            sample_interval = 1;
        }

        // Main backtest loop
        for (i, timestamp) in timestamps.iter().enumerate() {
            let current_bars = aligned_data.get(timestamp).unwrap();

            // Update prices and record equity
            let prices: HashMap<String, f64> = current_bars
                .iter()
                .map(|(s, b)| (s.clone(), b.close))
                .collect();
            portfolio.record_equity(*timestamp, &prices);

            // Skip warmup
            if i < warmup {
                continue;
            }

            // Build historical bars up to current point
            let historical: HashMap<String, Vec<Bar>> = symbols
                .iter()
                .filter_map(|s| {
                    self.data.get(s).map(|bars| {
                        let filtered: Vec<Bar> = bars
                            .iter()
                            .filter(|b| b.timestamp <= *timestamp)
                            .cloned()
                            .collect();
                        (s.clone(), filtered)
                    })
                })
                .collect();

            // Calculate current weights
            let equity = portfolio.equity(&prices);
            let weights: HashMap<String, f64> = symbols
                .iter()
                .map(|s| {
                    let pos_value = portfolio
                        .position(s)
                        .map(|p| p.quantity * prices.get(s).unwrap_or(&0.0))
                        .unwrap_or(0.0);
                    (
                        s.clone(),
                        if equity > 0.0 {
                            pos_value / equity
                        } else {
                            0.0
                        },
                    )
                })
                .collect();

            // Sample weight history
            if i % sample_interval == 0 {
                weight_history.push((*timestamp, weights.clone()));
            }

            // Build context
            let positions: HashMap<String, f64> = symbols
                .iter()
                .map(|s| (s.clone(), portfolio.position_qty(s)))
                .collect();

            let ctx = PortfolioContext {
                bar_index: i,
                current_bars,
                bars: &historical,
                positions,
                cash: portfolio.cash,
                equity,
                weights,
                symbols: &symbols,
            };

            // Get allocation signal
            let signal = strategy.on_bars(&ctx);

            // Execute signal
            match signal {
                AllocationSignal::Allocate(allocations) => {
                    self.execute_allocations(&mut portfolio, &allocations, &prices, equity)?;
                }
                AllocationSignal::Rebalance(target_weights) => {
                    self.execute_rebalance(&mut portfolio, &target_weights, &prices, equity)?;
                }
                AllocationSignal::ExitAll => {
                    self.exit_all_positions(&mut portfolio, current_bars)?;
                }
                AllocationSignal::Hold => {}
            }
        }

        strategy.on_finish();

        // Calculate results
        let equity_curve = portfolio.equity_curve().to_vec();
        let trades = portfolio.trades().to_vec();
        let final_equity = equity_curve
            .last()
            .map(|e| e.equity)
            .unwrap_or(self.config.initial_capital);

        let total_return_pct =
            (final_equity - self.config.initial_capital) / self.config.initial_capital * 100.0;

        let days = (end_time - start_time).num_days() as f64;
        let years = days / 365.0;
        let annual_return_pct = if years > 0.0 {
            ((final_equity / self.config.initial_capital).powf(1.0 / years) - 1.0) * 100.0
        } else {
            0.0
        };

        let max_drawdown_pct = equity_curve
            .iter()
            .map(|e| e.drawdown_pct)
            .fold(0.0_f64, |a, b| a.max(b));

        let returns: Vec<f64> = equity_curve
            .windows(2)
            .map(|w| (w[1].equity - w[0].equity) / w[0].equity)
            .collect();

        let sharpe_ratio = self.calculate_sharpe(&returns);
        let sortino_ratio = self.calculate_sortino(&returns);

        let closed_trades: Vec<_> = trades.iter().filter(|t| t.is_closed()).collect();
        let total_trades = closed_trades.len();

        let mut trades_by_symbol: HashMap<String, usize> = HashMap::new();
        for trade in &closed_trades {
            *trades_by_symbol.entry(trade.symbol.clone()).or_insert(0) += 1;
        }

        Ok(MultiAssetResult {
            strategy_name: strategy.name().to_string(),
            symbols,
            initial_capital: self.config.initial_capital,
            final_equity,
            total_return_pct,
            annual_return_pct,
            max_drawdown_pct,
            sharpe_ratio,
            sortino_ratio,
            total_trades,
            trades_by_symbol,
            trades,
            equity_curve,
            start_time,
            end_time,
            weight_history,
        })
    }

    /// Find common date range across all symbols.
    fn find_common_range(
        &self,
        symbols: &[String],
    ) -> Result<(usize, DateTime<Utc>, DateTime<Utc>)> {
        let mut start = None;
        let mut end = None;
        let mut min_len = usize::MAX;

        for symbol in symbols {
            let bars = self.data.get(symbol).ok_or_else(|| {
                BacktestError::DataError(format!("No data for symbol: {}", symbol))
            })?;

            if bars.is_empty() {
                continue;
            }

            let s = bars.first().unwrap().timestamp;
            let e = bars.last().unwrap().timestamp;

            start = Some(start.map_or(s, |curr: DateTime<Utc>| curr.max(s)));
            end = Some(end.map_or(e, |curr: DateTime<Utc>| curr.min(e)));
            min_len = min_len.min(bars.len());
        }

        let start = start.ok_or(BacktestError::NoData)?;
        let end = end.ok_or(BacktestError::NoData)?;

        Ok((min_len, start, end))
    }

    /// Align data by timestamp across symbols.
    fn align_data(
        &self,
        symbols: &[String],
    ) -> Result<BTreeMap<DateTime<Utc>, HashMap<String, Bar>>> {
        let mut aligned: BTreeMap<DateTime<Utc>, HashMap<String, Bar>> = BTreeMap::new();

        // Collect all timestamps
        for symbol in symbols {
            if let Some(bars) = self.data.get(symbol) {
                for bar in bars {
                    aligned
                        .entry(bar.timestamp)
                        .or_default()
                        .insert(symbol.clone(), bar.clone());
                }
            }
        }

        // Filter to only include timestamps where all symbols have data
        let num_symbols = symbols.len();
        aligned.retain(|_, bars| bars.len() == num_symbols);

        if aligned.is_empty() {
            return Err(BacktestError::DataError(
                "No overlapping data across symbols".to_string(),
            ));
        }

        Ok(aligned)
    }

    /// Execute target allocations.
    fn execute_allocations(
        &self,
        portfolio: &mut Portfolio,
        allocations: &HashMap<String, Allocation>,
        prices: &HashMap<String, f64>,
        equity: f64,
    ) -> Result<()> {
        for (symbol, allocation) in allocations {
            let price = prices.get(symbol).copied().unwrap_or(0.0);
            if price <= 0.0 {
                continue;
            }

            let target_value = equity * allocation.weight;
            let current_qty = portfolio.position_qty(symbol);
            let current_value = current_qty * price;
            let diff_value = target_value - current_value;

            if diff_value.abs() < 100.0 {
                // Skip small adjustments
                continue;
            }

            let qty_change = diff_value / price;
            if qty_change.abs() < 0.01 {
                continue;
            }

            let bar = Bar::new(Utc::now(), price, price, price, price, 0.0);

            if qty_change > 0.0 {
                let order = Order::market(symbol, Side::Buy, qty_change, Utc::now());
                let _ = portfolio.execute_with_fill_probability(
                    &order,
                    &bar,
                    self.config.fill_probability,
                );
            } else {
                let order = Order::market(symbol, Side::Sell, qty_change.abs(), Utc::now());
                let _ = portfolio.execute_with_fill_probability(
                    &order,
                    &bar,
                    self.config.fill_probability,
                );
            }
        }

        Ok(())
    }

    /// Execute rebalance to target weights.
    fn execute_rebalance(
        &self,
        portfolio: &mut Portfolio,
        target_weights: &HashMap<String, f64>,
        prices: &HashMap<String, f64>,
        equity: f64,
    ) -> Result<()> {
        let allocations: HashMap<String, Allocation> = target_weights
            .iter()
            .map(|(s, w)| (s.clone(), Allocation::new(*w)))
            .collect();

        self.execute_allocations(portfolio, &allocations, prices, equity)
    }

    /// Exit all positions.
    fn exit_all_positions(
        &self,
        portfolio: &mut Portfolio,
        current_bars: &HashMap<String, Bar>,
    ) -> Result<()> {
        let positions: Vec<(String, f64)> = portfolio
            .positions()
            .iter()
            .map(|(s, p)| (s.clone(), p.quantity))
            .collect();

        for (symbol, qty) in positions {
            if qty.abs() < 0.01 {
                continue;
            }

            let bar = current_bars
                .get(&symbol)
                .cloned()
                .unwrap_or_else(|| Bar::new(Utc::now(), 100.0, 100.0, 100.0, 100.0, 0.0));

            let side = if qty > 0.0 { Side::Sell } else { Side::Buy };
            let order = Order::market(&symbol, side, qty.abs(), Utc::now());
            let _ =
                portfolio.execute_with_fill_probability(&order, &bar, self.config.fill_probability);
        }

        Ok(())
    }

    fn calculate_sharpe(&self, returns: &[f64]) -> f64 {
        if returns.is_empty() {
            return 0.0;
        }
        let mean: f64 = returns.iter().sum::<f64>() / returns.len() as f64;
        let variance: f64 =
            returns.iter().map(|r| (r - mean).powi(2)).sum::<f64>() / returns.len() as f64;
        let std_dev = variance.sqrt();
        if std_dev == 0.0 {
            return 0.0;
        }
        (mean / std_dev) * 252.0_f64.sqrt()
    }

    fn calculate_sortino(&self, returns: &[f64]) -> f64 {
        if returns.is_empty() {
            return 0.0;
        }
        let mean: f64 = returns.iter().sum::<f64>() / returns.len() as f64;
        let downside: Vec<f64> = returns.iter().filter(|&&r| r < 0.0).copied().collect();
        if downside.is_empty() {
            return if mean > 0.0 { f64::INFINITY } else { 0.0 };
        }
        let downside_var: f64 =
            downside.iter().map(|r| r.powi(2)).sum::<f64>() / downside.len() as f64;
        let downside_dev = downside_var.sqrt();
        if downside_dev == 0.0 {
            return 0.0;
        }
        (mean / downside_dev) * 252.0_f64.sqrt()
    }
}

/// Simple equal-weight portfolio strategy.
pub struct EqualWeightStrategy {
    rebalance_frequency: usize,
    last_rebalance: usize,
}

impl EqualWeightStrategy {
    /// Create new equal-weight strategy.
    pub fn new(rebalance_frequency: usize) -> Self {
        Self {
            rebalance_frequency,
            last_rebalance: 0,
        }
    }
}

impl PortfolioStrategy for EqualWeightStrategy {
    fn name(&self) -> &str {
        "Equal Weight"
    }

    fn on_bars(&mut self, ctx: &PortfolioContext) -> AllocationSignal {
        // Rebalance at specified frequency
        if ctx.bar_index < self.last_rebalance + self.rebalance_frequency {
            return AllocationSignal::Hold;
        }

        self.last_rebalance = ctx.bar_index;

        let weight = 1.0 / ctx.symbols.len() as f64;
        let weights: HashMap<String, f64> =
            ctx.symbols.iter().map(|s| (s.clone(), weight)).collect();

        AllocationSignal::Rebalance(weights)
    }
}

/// Momentum-based portfolio strategy.
pub struct MomentumPortfolioStrategy {
    lookback: usize,
    top_n: usize,
    rebalance_frequency: usize,
    last_rebalance: usize,
}

impl MomentumPortfolioStrategy {
    /// Create new momentum portfolio strategy.
    pub fn new(lookback: usize, top_n: usize, rebalance_frequency: usize) -> Self {
        Self {
            lookback,
            top_n,
            rebalance_frequency,
            last_rebalance: 0,
        }
    }
}

impl PortfolioStrategy for MomentumPortfolioStrategy {
    fn name(&self) -> &str {
        "Momentum Portfolio"
    }

    fn warmup_period(&self) -> usize {
        self.lookback
    }

    fn on_bars(&mut self, ctx: &PortfolioContext) -> AllocationSignal {
        if ctx.bar_index < self.last_rebalance + self.rebalance_frequency {
            return AllocationSignal::Hold;
        }

        self.last_rebalance = ctx.bar_index;

        // Calculate momentum for each symbol
        let mut momentums: Vec<(String, f64)> = ctx
            .symbols
            .iter()
            .filter_map(|s| {
                let bars = ctx.history(s)?;
                if bars.len() < self.lookback {
                    return None;
                }
                let old_price = bars[bars.len() - self.lookback].close;
                let new_price = bars.last()?.close;
                let momentum = (new_price - old_price) / old_price;
                Some((s.clone(), momentum))
            })
            .collect();

        // Sort by momentum descending
        momentums.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());

        // Select top N
        let selected: Vec<&str> = momentums
            .iter()
            .take(self.top_n.min(momentums.len()))
            .filter(|(_, m)| *m > 0.0) // Only positive momentum
            .map(|(s, _)| s.as_str())
            .collect();

        if selected.is_empty() {
            return AllocationSignal::ExitAll;
        }

        let weight = 1.0 / selected.len() as f64;
        let weights: HashMap<String, f64> = selected
            .into_iter()
            .map(|s| (s.to_string(), weight))
            .collect();

        AllocationSignal::Rebalance(weights)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::TimeZone;

    fn create_test_bars(count: usize, base_price: f64, trend: f64) -> Vec<Bar> {
        (0..count)
            .map(|i| {
                let price = base_price * (1.0 + trend).powi(i as i32);
                Bar::new(
                    Utc.with_ymd_and_hms(2024, 1, 1, 0, 0, 0).unwrap()
                        + chrono::Duration::days(i as i64),
                    price * 0.99,
                    price * 1.02,
                    price * 0.98,
                    price,
                    1000000.0,
                )
            })
            .collect()
    }

    #[test]
    fn test_allocation() {
        let alloc = Allocation::new(0.5);
        assert!((alloc.weight - 0.5).abs() < 0.001);

        let bounded = Allocation::with_bounds(0.6, 0.1, 0.5);
        assert!((bounded.weight - 0.5).abs() < 0.001); // Clamped to max
    }

    #[test]
    fn test_equal_weight_strategy() {
        let strategy = EqualWeightStrategy::new(20);
        assert_eq!(strategy.name(), "Equal Weight");
    }

    #[test]
    fn test_momentum_portfolio_strategy() {
        let strategy = MomentumPortfolioStrategy::new(20, 3, 5);
        assert_eq!(strategy.name(), "Momentum Portfolio");
        assert_eq!(strategy.warmup_period(), 20);
    }

    #[test]
    fn test_multi_asset_engine_creation() {
        let config = BacktestConfig::default();
        let mut engine = MultiAssetEngine::new(config);

        let bars1 = create_test_bars(100, 100.0, 0.001);
        let bars2 = create_test_bars(100, 50.0, 0.002);

        engine.add_data("ASSET1", bars1);
        engine.add_data("ASSET2", bars2);
    }

    #[test]
    fn test_multi_asset_backtest() {
        let config = BacktestConfig {
            initial_capital: 100_000.0,
            show_progress: false,
            ..Default::default()
        };

        let mut engine = MultiAssetEngine::new(config);

        let bars1 = create_test_bars(100, 100.0, 0.001);
        let bars2 = create_test_bars(100, 50.0, 0.002);

        engine.add_data("ASSET1", bars1);
        engine.add_data("ASSET2", bars2);

        let mut strategy = EqualWeightStrategy::new(20);
        let result = engine.run(&mut strategy).unwrap();

        assert_eq!(result.symbols.len(), 2);
        assert!(result.final_equity > 0.0);
        assert!(!result.equity_curve.is_empty());
    }

    fn create_portfolio_context_for_testing() -> (
        PortfolioContext<'static>,
        HashMap<String, Bar>,
        HashMap<String, Vec<Bar>>,
        Vec<String>,
    ) {
        // Create test data with different price trends for cross-sectional testing
        let bars_a = create_test_bars(50, 100.0, 0.02); // Strong uptrend
        let bars_b = create_test_bars(50, 100.0, 0.01); // Moderate uptrend
        let bars_c = create_test_bars(50, 100.0, 0.00); // Flat
        let bars_d = create_test_bars(50, 100.0, -0.01); // Downtrend

        let mut all_bars = HashMap::new();
        all_bars.insert("ASSET_A".to_string(), bars_a.clone());
        all_bars.insert("ASSET_B".to_string(), bars_b.clone());
        all_bars.insert("ASSET_C".to_string(), bars_c.clone());
        all_bars.insert("ASSET_D".to_string(), bars_d.clone());

        let mut current_bars = HashMap::new();
        current_bars.insert("ASSET_A".to_string(), bars_a.last().unwrap().clone());
        current_bars.insert("ASSET_B".to_string(), bars_b.last().unwrap().clone());
        current_bars.insert("ASSET_C".to_string(), bars_c.last().unwrap().clone());
        current_bars.insert("ASSET_D".to_string(), bars_d.last().unwrap().clone());

        let symbols = vec![
            "ASSET_A".to_string(),
            "ASSET_B".to_string(),
            "ASSET_C".to_string(),
            "ASSET_D".to_string(),
        ];

        // These need to be 'static or have the same lifetime
        // For testing, we'll need to leak them or Box them
        // Let's use Box::leak to create static references
        let all_bars_static = Box::leak(Box::new(all_bars.clone()));
        let current_bars_static = Box::leak(Box::new(current_bars.clone()));
        let symbols_static = Box::leak(Box::new(symbols.clone()));

        let ctx = PortfolioContext {
            bar_index: 49,
            current_bars: current_bars_static,
            bars: all_bars_static,
            positions: HashMap::new(),
            cash: 100000.0,
            equity: 100000.0,
            weights: HashMap::new(),
            symbols: symbols_static,
        };

        (ctx, current_bars, all_bars, symbols)
    }

    #[test]
    fn test_rank_percentile_momentum() {
        let (ctx, _, _, _) = create_portfolio_context_for_testing();

        // ASSET_A has strongest momentum (2% trend)
        let rank_a = ctx
            .rank_percentile(
                "ASSET_A",
                |bars, lb| {
                    if bars.len() < lb + 1 {
                        return None;
                    }
                    let start = bars[bars.len() - lb - 1].close;
                    let end = bars.last()?.close;
                    Some((end - start) / start)
                },
                20,
            )
            .unwrap();

        // ASSET_D has weakest momentum (-1% trend)
        let rank_d = ctx
            .rank_percentile(
                "ASSET_D",
                |bars, lb| {
                    if bars.len() < lb + 1 {
                        return None;
                    }
                    let start = bars[bars.len() - lb - 1].close;
                    let end = bars.last()?.close;
                    Some((end - start) / start)
                },
                20,
            )
            .unwrap();

        // ASSET_A should rank highest (1.0 or close to it)
        assert!(
            rank_a > 0.8,
            "ASSET_A should have high momentum rank: {}",
            rank_a
        );

        // ASSET_D should rank lowest (0.0 or close to it)
        assert!(
            rank_d < 0.2,
            "ASSET_D should have low momentum rank: {}",
            rank_d
        );

        // Rank should be ordered: A > B > C > D
        assert!(rank_a > rank_d, "Strong momentum should rank higher than weak");
    }

    #[test]
    fn test_cross_sectional_zscore() {
        let (ctx, _, _, _) = create_portfolio_context_for_testing();

        // Calculate z-score of momentum for each asset
        let zscore_a = ctx
            .cross_sectional_zscore(
                "ASSET_A",
                |bars, lb| {
                    if bars.len() < lb + 1 {
                        return None;
                    }
                    let start = bars[bars.len() - lb - 1].close;
                    let end = bars.last()?.close;
                    Some((end - start) / start)
                },
                20,
            )
            .unwrap();

        let zscore_d = ctx
            .cross_sectional_zscore(
                "ASSET_D",
                |bars, lb| {
                    if bars.len() < lb + 1 {
                        return None;
                    }
                    let start = bars[bars.len() - lb - 1].close;
                    let end = bars.last()?.close;
                    Some((end - start) / start)
                },
                20,
            )
            .unwrap();

        // ASSET_A should have positive z-score (above average)
        assert!(
            zscore_a > 0.0,
            "ASSET_A should have positive z-score: {}",
            zscore_a
        );

        // ASSET_D should have negative z-score (below average)
        assert!(
            zscore_d < 0.0,
            "ASSET_D should have negative z-score: {}",
            zscore_d
        );
    }

    #[test]
    fn test_relative_momentum() {
        let (ctx, _, _, _) = create_portfolio_context_for_testing();

        // ASSET_A should have positive relative momentum (outperforming)
        let rel_mom_a = ctx.relative_momentum("ASSET_A", 20).unwrap();

        // ASSET_D should have negative relative momentum (underperforming)
        let rel_mom_d = ctx.relative_momentum("ASSET_D", 20).unwrap();

        assert!(
            rel_mom_a > 0.0,
            "ASSET_A should outperform universe: {}",
            rel_mom_a
        );
        assert!(
            rel_mom_d < 0.0,
            "ASSET_D should underperform universe: {}",
            rel_mom_d
        );

        // Relative momentum should be additive-inverse around average
        // (not exactly due to equal-weighting, but should be opposite signs)
        assert!(
            rel_mom_a > rel_mom_d,
            "Strong asset should have higher relative momentum than weak"
        );
    }

    #[test]
    fn test_rank_by_metric_momentum() {
        let (ctx, _, _, _) = create_portfolio_context_for_testing();

        let rank_a = ctx.rank_by_metric("ASSET_A", "momentum", 20).unwrap();
        let rank_d = ctx.rank_by_metric("ASSET_D", "momentum", 20).unwrap();

        // Same expectations as rank_percentile test
        assert!(
            rank_a > 0.8,
            "ASSET_A should have high momentum rank: {}",
            rank_a
        );
        assert!(
            rank_d < 0.2,
            "ASSET_D should have low momentum rank: {}",
            rank_d
        );
    }

    #[test]
    fn test_rank_by_metric_volatility() {
        let (ctx, _, _, _) = create_portfolio_context_for_testing();

        // All assets should have similar volatility since they follow geometric trends
        let rank_a = ctx.rank_by_metric("ASSET_A", "volatility", 20);
        let rank_b = ctx.rank_by_metric("ASSET_B", "volatility", 20);

        assert!(rank_a.is_some(), "Volatility rank should be calculated");
        assert!(rank_b.is_some(), "Volatility rank should be calculated");
    }

    #[test]
    fn test_rank_by_metric_volume() {
        let (ctx, _, _, _) = create_portfolio_context_for_testing();

        // All test bars have same volume (1000000.0), so ranks should be equal
        let rank_a = ctx.rank_by_metric("ASSET_A", "volume", 20).unwrap();

        // With equal volumes, each asset should have similar ranks
        // (exact value depends on tie-breaking, but should be around 0.33-0.66)
        assert!(
            rank_a >= 0.0 && rank_a <= 1.0,
            "Volume rank should be between 0 and 1: {}",
            rank_a
        );
    }

    #[test]
    fn test_rank_percentile_insufficient_symbols() {
        // Create context with only one symbol
        let bars = create_test_bars(50, 100.0, 0.01);
        let mut all_bars = HashMap::new();
        all_bars.insert("ASSET_A".to_string(), bars.clone());

        let mut current_bars = HashMap::new();
        current_bars.insert("ASSET_A".to_string(), bars.last().unwrap().clone());

        let symbols = vec!["ASSET_A".to_string()];

        let all_bars_static = Box::leak(Box::new(all_bars));
        let current_bars_static = Box::leak(Box::new(current_bars));
        let symbols_static = Box::leak(Box::new(symbols));

        let ctx = PortfolioContext {
            bar_index: 49,
            current_bars: current_bars_static,
            bars: all_bars_static,
            positions: HashMap::new(),
            cash: 100000.0,
            equity: 100000.0,
            weights: HashMap::new(),
            symbols: symbols_static,
        };

        // Should return None with only one symbol
        let rank = ctx.rank_percentile(
            "ASSET_A",
            |bars, lb| {
                if bars.len() < lb + 1 {
                    return None;
                }
                let start = bars[bars.len() - lb - 1].close;
                let end = bars.last()?.close;
                Some((end - start) / start)
            },
            20,
        );

        assert!(
            rank.is_none(),
            "Should return None with insufficient symbols"
        );
    }

    #[test]
    fn test_cross_sectional_zscore_all_equal() {
        // Create context where all assets have identical values
        let bars = create_test_bars(50, 100.0, 0.01);
        let mut all_bars = HashMap::new();
        all_bars.insert("ASSET_A".to_string(), bars.clone());
        all_bars.insert("ASSET_B".to_string(), bars.clone());
        all_bars.insert("ASSET_C".to_string(), bars.clone());

        let mut current_bars = HashMap::new();
        current_bars.insert("ASSET_A".to_string(), bars.last().unwrap().clone());
        current_bars.insert("ASSET_B".to_string(), bars.last().unwrap().clone());
        current_bars.insert("ASSET_C".to_string(), bars.last().unwrap().clone());

        let symbols = vec![
            "ASSET_A".to_string(),
            "ASSET_B".to_string(),
            "ASSET_C".to_string(),
        ];

        let all_bars_static = Box::leak(Box::new(all_bars));
        let current_bars_static = Box::leak(Box::new(current_bars));
        let symbols_static = Box::leak(Box::new(symbols));

        let ctx = PortfolioContext {
            bar_index: 49,
            current_bars: current_bars_static,
            bars: all_bars_static,
            positions: HashMap::new(),
            cash: 100000.0,
            equity: 100000.0,
            weights: HashMap::new(),
            symbols: symbols_static,
        };

        // When all values are equal, z-score should be 0.0
        let zscore = ctx
            .cross_sectional_zscore(
                "ASSET_A",
                |bars, lb| {
                    if bars.len() < lb + 1 {
                        return None;
                    }
                    let start = bars[bars.len() - lb - 1].close;
                    let end = bars.last()?.close;
                    Some((end - start) / start)
                },
                20,
            )
            .unwrap();

        assert_eq!(zscore, 0.0, "Z-score should be 0 when all values are equal");
    }

    #[test]
    fn test_relative_momentum_insufficient_data() {
        let (ctx, _, _, _) = create_portfolio_context_for_testing();

        // Request lookback longer than available data
        let rel_mom = ctx.relative_momentum("ASSET_A", 100);

        assert!(
            rel_mom.is_none(),
            "Should return None with insufficient data"
        );
    }
}
