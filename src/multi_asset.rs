//! Multi-asset portfolio backtesting support.
//!
//! This module enables backtesting strategies across multiple assets simultaneously,
//! supporting portfolio-level risk management and rebalancing.
//!
//! # Example
//!
//! ```ignore
//! use mantis::multi_asset::{MultiAssetEngine, PortfolioStrategy, AllocationSignal};
//! use mantis::engine::BacktestConfig;
//!
//! let config = BacktestConfig::default();
//! let mut engine = MultiAssetEngine::new(config);
//!
//! engine.add_data("AAPL", aapl_bars);
//! engine.add_data("GOOG", goog_bars);
//!
//! let result = engine.run(&mut strategy)?;
//! ```

use crate::data::DataManager;
use crate::engine::BacktestConfig;
use crate::error::{BacktestError, Result};
use crate::portfolio::Portfolio;
use crate::types::{Bar, EquityPoint, Order, Side, Trade};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::{BTreeMap, HashMap};
use tracing::info;

/// Target allocation for an asset as a fraction of portfolio.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct Allocation {
    /// Target weight (0.0 to 1.0).
    pub weight: f64,
    /// Minimum weight (optional floor).
    pub min_weight: f64,
    /// Maximum weight (optional cap).
    pub max_weight: f64,
}

impl Allocation {
    /// Create a new allocation with target weight.
    pub fn new(weight: f64) -> Self {
        Self {
            weight: weight.clamp(0.0, 1.0),
            min_weight: 0.0,
            max_weight: 1.0,
        }
    }

    /// Create allocation with bounds.
    pub fn with_bounds(weight: f64, min: f64, max: f64) -> Self {
        Self {
            weight: weight.clamp(min, max),
            min_weight: min,
            max_weight: max,
        }
    }
}

/// Signal generated by a portfolio strategy.
#[derive(Debug, Clone)]
pub enum AllocationSignal {
    /// Target allocations for all assets.
    Allocate(HashMap<String, Allocation>),
    /// Rebalance to specified weights.
    Rebalance(HashMap<String, f64>),
    /// Exit all positions.
    ExitAll,
    /// No change.
    Hold,
}

/// Context for portfolio strategy decisions.
#[derive(Debug)]
pub struct PortfolioContext<'a> {
    /// Current bar index.
    pub bar_index: usize,
    /// Current bars for all symbols.
    pub current_bars: &'a HashMap<String, Bar>,
    /// Historical bars for all symbols.
    pub bars: &'a HashMap<String, Vec<Bar>>,
    /// Current positions (symbol -> quantity).
    pub positions: HashMap<String, f64>,
    /// Current cash.
    pub cash: f64,
    /// Total portfolio equity.
    pub equity: f64,
    /// Current weights of each position.
    pub weights: HashMap<String, f64>,
    /// Symbols being traded.
    pub symbols: &'a [String],
}

impl<'a> PortfolioContext<'a> {
    /// Get current price for a symbol.
    pub fn price(&self, symbol: &str) -> Option<f64> {
        self.current_bars.get(symbol).map(|b| b.close)
    }

    /// Get historical bars for a symbol.
    pub fn history(&self, symbol: &str) -> Option<&Vec<Bar>> {
        self.bars.get(symbol)
    }

    /// Get current weight of a symbol.
    pub fn weight(&self, symbol: &str) -> f64 {
        self.weights.get(symbol).copied().unwrap_or(0.0)
    }

    /// Check if we have a position in a symbol.
    pub fn has_position(&self, symbol: &str) -> bool {
        self.positions.get(symbol).is_some_and(|&q| q.abs() > 0.0)
    }

    /// Calculate correlation between two symbols over a lookback period.
    pub fn correlation(&self, symbol1: &str, symbol2: &str, lookback: usize) -> Option<f64> {
        let bars1 = self.bars.get(symbol1)?;
        let bars2 = self.bars.get(symbol2)?;

        if bars1.len() < lookback || bars2.len() < lookback {
            return None;
        }

        let returns1: Vec<f64> = bars1[bars1.len() - lookback..]
            .windows(2)
            .map(|w| (w[1].close - w[0].close) / w[0].close)
            .collect();

        let returns2: Vec<f64> = bars2[bars2.len() - lookback..]
            .windows(2)
            .map(|w| (w[1].close - w[0].close) / w[0].close)
            .collect();

        if returns1.len() != returns2.len() || returns1.is_empty() {
            return None;
        }

        let mean1: f64 = returns1.iter().sum::<f64>() / returns1.len() as f64;
        let mean2: f64 = returns2.iter().sum::<f64>() / returns2.len() as f64;

        let cov: f64 = returns1
            .iter()
            .zip(returns2.iter())
            .map(|(r1, r2)| (r1 - mean1) * (r2 - mean2))
            .sum::<f64>()
            / returns1.len() as f64;

        let std1: f64 = (returns1.iter().map(|r| (r - mean1).powi(2)).sum::<f64>()
            / returns1.len() as f64)
            .sqrt();
        let std2: f64 = (returns2.iter().map(|r| (r - mean2).powi(2)).sum::<f64>()
            / returns2.len() as f64)
            .sqrt();

        if std1 > 0.0 && std2 > 0.0 {
            Some(cov / (std1 * std2))
        } else {
            None
        }
    }
}

/// Trait for multi-asset portfolio strategies.
pub trait PortfolioStrategy: Send + Sync {
    /// Returns the name of the strategy.
    fn name(&self) -> &str;

    /// Called once at the start of the backtest.
    fn init(&mut self) {}

    /// Generate allocation signals based on current state.
    fn on_bars(&mut self, ctx: &PortfolioContext) -> AllocationSignal;

    /// Called at the end of the backtest.
    fn on_finish(&mut self) {}

    /// Minimum bars needed before the strategy can generate signals.
    fn warmup_period(&self) -> usize {
        0
    }
}

/// Result from a multi-asset backtest.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MultiAssetResult {
    /// Strategy name.
    pub strategy_name: String,
    /// Symbols traded.
    pub symbols: Vec<String>,
    /// Initial capital.
    pub initial_capital: f64,
    /// Final equity.
    pub final_equity: f64,
    /// Total return percentage.
    pub total_return_pct: f64,
    /// Annual return percentage.
    pub annual_return_pct: f64,
    /// Maximum drawdown percentage.
    pub max_drawdown_pct: f64,
    /// Sharpe ratio.
    pub sharpe_ratio: f64,
    /// Sortino ratio.
    pub sortino_ratio: f64,
    /// Total trades across all assets.
    pub total_trades: usize,
    /// Trades by symbol.
    pub trades_by_symbol: HashMap<String, usize>,
    /// All trades.
    pub trades: Vec<Trade>,
    /// Equity curve.
    pub equity_curve: Vec<EquityPoint>,
    /// Start time.
    pub start_time: DateTime<Utc>,
    /// End time.
    pub end_time: DateTime<Utc>,
    /// Weight history (sampled).
    pub weight_history: Vec<(DateTime<Utc>, HashMap<String, f64>)>,
}

/// Multi-asset backtest engine.
pub struct MultiAssetEngine {
    config: BacktestConfig,
    data: DataManager,
}

impl MultiAssetEngine {
    /// Create a new multi-asset engine.
    pub fn new(config: BacktestConfig) -> Self {
        Self {
            config,
            data: DataManager::new(),
        }
    }

    /// Add data for a symbol.
    pub fn add_data(&mut self, symbol: impl Into<String>, bars: Vec<Bar>) {
        self.data.add(symbol, bars);
    }

    /// Run multi-asset backtest.
    pub fn run(&self, strategy: &mut dyn PortfolioStrategy) -> Result<MultiAssetResult> {
        let symbols: Vec<String> = self.data.symbols().iter().map(|s| s.to_string()).collect();

        if symbols.is_empty() {
            return Err(BacktestError::NoData);
        }

        // Find common date range
        let (min_len, start_time, end_time) = self.find_common_range(&symbols)?;

        info!(
            "Running multi-asset backtest: {} on {} symbols ({} bars)",
            strategy.name(),
            symbols.len(),
            min_len
        );

        strategy.init();

        let mut portfolio =
            Portfolio::with_cost_model(self.config.initial_capital, self.config.cost_model.clone());
        portfolio.allow_short = self.config.allow_short;
        portfolio.fractional_shares = self.config.fractional_shares;
        portfolio.set_asset_configs(self.data.asset_configs());
        let volume_profiles = self.data.volume_profiles();
        portfolio.set_volume_profiles(&volume_profiles);

        let warmup = strategy.warmup_period();

        // Align data by date
        let aligned_data = self.align_data(&symbols)?;
        let timestamps: Vec<DateTime<Utc>> = aligned_data.keys().cloned().collect();

        let mut weight_history = Vec::new();
        let mut sample_interval = timestamps.len() / 100;
        if sample_interval == 0 {
            sample_interval = 1;
        }

        // Main backtest loop
        for (i, timestamp) in timestamps.iter().enumerate() {
            let current_bars = aligned_data.get(timestamp).unwrap();

            // Update prices and record equity
            let prices: HashMap<String, f64> = current_bars
                .iter()
                .map(|(s, b)| (s.clone(), b.close))
                .collect();
            portfolio.record_equity(*timestamp, &prices);

            // Skip warmup
            if i < warmup {
                continue;
            }

            // Build historical bars up to current point
            let historical: HashMap<String, Vec<Bar>> = symbols
                .iter()
                .filter_map(|s| {
                    self.data.get(s).map(|bars| {
                        let filtered: Vec<Bar> = bars
                            .iter()
                            .filter(|b| b.timestamp <= *timestamp)
                            .cloned()
                            .collect();
                        (s.clone(), filtered)
                    })
                })
                .collect();

            // Calculate current weights
            let equity = portfolio.equity(&prices);
            let weights: HashMap<String, f64> = symbols
                .iter()
                .map(|s| {
                    let pos_value = portfolio
                        .position(s)
                        .map(|p| p.quantity * prices.get(s).unwrap_or(&0.0))
                        .unwrap_or(0.0);
                    (
                        s.clone(),
                        if equity > 0.0 {
                            pos_value / equity
                        } else {
                            0.0
                        },
                    )
                })
                .collect();

            // Sample weight history
            if i % sample_interval == 0 {
                weight_history.push((*timestamp, weights.clone()));
            }

            // Build context
            let positions: HashMap<String, f64> = symbols
                .iter()
                .map(|s| (s.clone(), portfolio.position_qty(s)))
                .collect();

            let ctx = PortfolioContext {
                bar_index: i,
                current_bars,
                bars: &historical,
                positions,
                cash: portfolio.cash,
                equity,
                weights,
                symbols: &symbols,
            };

            // Get allocation signal
            let signal = strategy.on_bars(&ctx);

            // Execute signal
            match signal {
                AllocationSignal::Allocate(allocations) => {
                    self.execute_allocations(&mut portfolio, &allocations, &prices, equity)?;
                }
                AllocationSignal::Rebalance(target_weights) => {
                    self.execute_rebalance(&mut portfolio, &target_weights, &prices, equity)?;
                }
                AllocationSignal::ExitAll => {
                    self.exit_all_positions(&mut portfolio, current_bars)?;
                }
                AllocationSignal::Hold => {}
            }
        }

        strategy.on_finish();

        // Calculate results
        let equity_curve = portfolio.equity_curve().to_vec();
        let trades = portfolio.trades().to_vec();
        let final_equity = equity_curve
            .last()
            .map(|e| e.equity)
            .unwrap_or(self.config.initial_capital);

        let total_return_pct =
            (final_equity - self.config.initial_capital) / self.config.initial_capital * 100.0;

        let days = (end_time - start_time).num_days() as f64;
        let years = days / 365.0;
        let annual_return_pct = if years > 0.0 {
            ((final_equity / self.config.initial_capital).powf(1.0 / years) - 1.0) * 100.0
        } else {
            0.0
        };

        let max_drawdown_pct = equity_curve
            .iter()
            .map(|e| e.drawdown_pct)
            .fold(0.0_f64, |a, b| a.max(b));

        let returns: Vec<f64> = equity_curve
            .windows(2)
            .map(|w| (w[1].equity - w[0].equity) / w[0].equity)
            .collect();

        let sharpe_ratio = self.calculate_sharpe(&returns);
        let sortino_ratio = self.calculate_sortino(&returns);

        let closed_trades: Vec<_> = trades.iter().filter(|t| t.is_closed()).collect();
        let total_trades = closed_trades.len();

        let mut trades_by_symbol: HashMap<String, usize> = HashMap::new();
        for trade in &closed_trades {
            *trades_by_symbol.entry(trade.symbol.clone()).or_insert(0) += 1;
        }

        Ok(MultiAssetResult {
            strategy_name: strategy.name().to_string(),
            symbols,
            initial_capital: self.config.initial_capital,
            final_equity,
            total_return_pct,
            annual_return_pct,
            max_drawdown_pct,
            sharpe_ratio,
            sortino_ratio,
            total_trades,
            trades_by_symbol,
            trades,
            equity_curve,
            start_time,
            end_time,
            weight_history,
        })
    }

    /// Find common date range across all symbols.
    fn find_common_range(
        &self,
        symbols: &[String],
    ) -> Result<(usize, DateTime<Utc>, DateTime<Utc>)> {
        let mut start = None;
        let mut end = None;
        let mut min_len = usize::MAX;

        for symbol in symbols {
            let bars = self.data.get(symbol).ok_or_else(|| {
                BacktestError::DataError(format!("No data for symbol: {}", symbol))
            })?;

            if bars.is_empty() {
                continue;
            }

            let s = bars.first().unwrap().timestamp;
            let e = bars.last().unwrap().timestamp;

            start = Some(start.map_or(s, |curr: DateTime<Utc>| curr.max(s)));
            end = Some(end.map_or(e, |curr: DateTime<Utc>| curr.min(e)));
            min_len = min_len.min(bars.len());
        }

        let start = start.ok_or(BacktestError::NoData)?;
        let end = end.ok_or(BacktestError::NoData)?;

        Ok((min_len, start, end))
    }

    /// Align data by timestamp across symbols.
    fn align_data(
        &self,
        symbols: &[String],
    ) -> Result<BTreeMap<DateTime<Utc>, HashMap<String, Bar>>> {
        let mut aligned: BTreeMap<DateTime<Utc>, HashMap<String, Bar>> = BTreeMap::new();

        // Collect all timestamps
        for symbol in symbols {
            if let Some(bars) = self.data.get(symbol) {
                for bar in bars {
                    aligned
                        .entry(bar.timestamp)
                        .or_default()
                        .insert(symbol.clone(), bar.clone());
                }
            }
        }

        // Filter to only include timestamps where all symbols have data
        let num_symbols = symbols.len();
        aligned.retain(|_, bars| bars.len() == num_symbols);

        if aligned.is_empty() {
            return Err(BacktestError::DataError(
                "No overlapping data across symbols".to_string(),
            ));
        }

        Ok(aligned)
    }

    /// Execute target allocations.
    fn execute_allocations(
        &self,
        portfolio: &mut Portfolio,
        allocations: &HashMap<String, Allocation>,
        prices: &HashMap<String, f64>,
        equity: f64,
    ) -> Result<()> {
        for (symbol, allocation) in allocations {
            let price = prices.get(symbol).copied().unwrap_or(0.0);
            if price <= 0.0 {
                continue;
            }

            let target_value = equity * allocation.weight;
            let current_qty = portfolio.position_qty(symbol);
            let current_value = current_qty * price;
            let diff_value = target_value - current_value;

            if diff_value.abs() < 100.0 {
                // Skip small adjustments
                continue;
            }

            let qty_change = diff_value / price;
            if qty_change.abs() < 0.01 {
                continue;
            }

            let bar = Bar::new(Utc::now(), price, price, price, price, 0.0);

            if qty_change > 0.0 {
                let order = Order::market(symbol, Side::Buy, qty_change, Utc::now());
                let _ = portfolio.execute_order(&order, &bar);
            } else {
                let order = Order::market(symbol, Side::Sell, qty_change.abs(), Utc::now());
                let _ = portfolio.execute_order(&order, &bar);
            }
        }

        Ok(())
    }

    /// Execute rebalance to target weights.
    fn execute_rebalance(
        &self,
        portfolio: &mut Portfolio,
        target_weights: &HashMap<String, f64>,
        prices: &HashMap<String, f64>,
        equity: f64,
    ) -> Result<()> {
        let allocations: HashMap<String, Allocation> = target_weights
            .iter()
            .map(|(s, w)| (s.clone(), Allocation::new(*w)))
            .collect();

        self.execute_allocations(portfolio, &allocations, prices, equity)
    }

    /// Exit all positions.
    fn exit_all_positions(
        &self,
        portfolio: &mut Portfolio,
        current_bars: &HashMap<String, Bar>,
    ) -> Result<()> {
        let positions: Vec<(String, f64)> = portfolio
            .positions()
            .iter()
            .map(|(s, p)| (s.clone(), p.quantity))
            .collect();

        for (symbol, qty) in positions {
            if qty.abs() < 0.01 {
                continue;
            }

            let bar = current_bars
                .get(&symbol)
                .cloned()
                .unwrap_or_else(|| Bar::new(Utc::now(), 100.0, 100.0, 100.0, 100.0, 0.0));

            let side = if qty > 0.0 { Side::Sell } else { Side::Buy };
            let order = Order::market(&symbol, side, qty.abs(), Utc::now());
            let _ = portfolio.execute_order(&order, &bar);
        }

        Ok(())
    }

    fn calculate_sharpe(&self, returns: &[f64]) -> f64 {
        if returns.is_empty() {
            return 0.0;
        }
        let mean: f64 = returns.iter().sum::<f64>() / returns.len() as f64;
        let variance: f64 =
            returns.iter().map(|r| (r - mean).powi(2)).sum::<f64>() / returns.len() as f64;
        let std_dev = variance.sqrt();
        if std_dev == 0.0 {
            return 0.0;
        }
        (mean / std_dev) * 252.0_f64.sqrt()
    }

    fn calculate_sortino(&self, returns: &[f64]) -> f64 {
        if returns.is_empty() {
            return 0.0;
        }
        let mean: f64 = returns.iter().sum::<f64>() / returns.len() as f64;
        let downside: Vec<f64> = returns.iter().filter(|&&r| r < 0.0).copied().collect();
        if downside.is_empty() {
            return if mean > 0.0 { f64::INFINITY } else { 0.0 };
        }
        let downside_var: f64 =
            downside.iter().map(|r| r.powi(2)).sum::<f64>() / downside.len() as f64;
        let downside_dev = downside_var.sqrt();
        if downside_dev == 0.0 {
            return 0.0;
        }
        (mean / downside_dev) * 252.0_f64.sqrt()
    }
}

/// Simple equal-weight portfolio strategy.
pub struct EqualWeightStrategy {
    rebalance_frequency: usize,
    last_rebalance: usize,
}

impl EqualWeightStrategy {
    /// Create new equal-weight strategy.
    pub fn new(rebalance_frequency: usize) -> Self {
        Self {
            rebalance_frequency,
            last_rebalance: 0,
        }
    }
}

impl PortfolioStrategy for EqualWeightStrategy {
    fn name(&self) -> &str {
        "Equal Weight"
    }

    fn on_bars(&mut self, ctx: &PortfolioContext) -> AllocationSignal {
        // Rebalance at specified frequency
        if ctx.bar_index < self.last_rebalance + self.rebalance_frequency {
            return AllocationSignal::Hold;
        }

        self.last_rebalance = ctx.bar_index;

        let weight = 1.0 / ctx.symbols.len() as f64;
        let weights: HashMap<String, f64> =
            ctx.symbols.iter().map(|s| (s.clone(), weight)).collect();

        AllocationSignal::Rebalance(weights)
    }
}

/// Momentum-based portfolio strategy.
pub struct MomentumPortfolioStrategy {
    lookback: usize,
    top_n: usize,
    rebalance_frequency: usize,
    last_rebalance: usize,
}

impl MomentumPortfolioStrategy {
    /// Create new momentum portfolio strategy.
    pub fn new(lookback: usize, top_n: usize, rebalance_frequency: usize) -> Self {
        Self {
            lookback,
            top_n,
            rebalance_frequency,
            last_rebalance: 0,
        }
    }
}

impl PortfolioStrategy for MomentumPortfolioStrategy {
    fn name(&self) -> &str {
        "Momentum Portfolio"
    }

    fn warmup_period(&self) -> usize {
        self.lookback
    }

    fn on_bars(&mut self, ctx: &PortfolioContext) -> AllocationSignal {
        if ctx.bar_index < self.last_rebalance + self.rebalance_frequency {
            return AllocationSignal::Hold;
        }

        self.last_rebalance = ctx.bar_index;

        // Calculate momentum for each symbol
        let mut momentums: Vec<(String, f64)> = ctx
            .symbols
            .iter()
            .filter_map(|s| {
                let bars = ctx.history(s)?;
                if bars.len() < self.lookback {
                    return None;
                }
                let old_price = bars[bars.len() - self.lookback].close;
                let new_price = bars.last()?.close;
                let momentum = (new_price - old_price) / old_price;
                Some((s.clone(), momentum))
            })
            .collect();

        // Sort by momentum descending
        momentums.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());

        // Select top N
        let selected: Vec<&str> = momentums
            .iter()
            .take(self.top_n.min(momentums.len()))
            .filter(|(_, m)| *m > 0.0) // Only positive momentum
            .map(|(s, _)| s.as_str())
            .collect();

        if selected.is_empty() {
            return AllocationSignal::ExitAll;
        }

        let weight = 1.0 / selected.len() as f64;
        let weights: HashMap<String, f64> = selected
            .into_iter()
            .map(|s| (s.to_string(), weight))
            .collect();

        AllocationSignal::Rebalance(weights)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::TimeZone;

    fn create_test_bars(count: usize, base_price: f64, trend: f64) -> Vec<Bar> {
        (0..count)
            .map(|i| {
                let price = base_price * (1.0 + trend).powi(i as i32);
                Bar::new(
                    Utc.with_ymd_and_hms(2024, 1, 1, 0, 0, 0).unwrap()
                        + chrono::Duration::days(i as i64),
                    price * 0.99,
                    price * 1.02,
                    price * 0.98,
                    price,
                    1000000.0,
                )
            })
            .collect()
    }

    #[test]
    fn test_allocation() {
        let alloc = Allocation::new(0.5);
        assert!((alloc.weight - 0.5).abs() < 0.001);

        let bounded = Allocation::with_bounds(0.6, 0.1, 0.5);
        assert!((bounded.weight - 0.5).abs() < 0.001); // Clamped to max
    }

    #[test]
    fn test_equal_weight_strategy() {
        let strategy = EqualWeightStrategy::new(20);
        assert_eq!(strategy.name(), "Equal Weight");
    }

    #[test]
    fn test_momentum_portfolio_strategy() {
        let strategy = MomentumPortfolioStrategy::new(20, 3, 5);
        assert_eq!(strategy.name(), "Momentum Portfolio");
        assert_eq!(strategy.warmup_period(), 20);
    }

    #[test]
    fn test_multi_asset_engine_creation() {
        let config = BacktestConfig::default();
        let mut engine = MultiAssetEngine::new(config);

        let bars1 = create_test_bars(100, 100.0, 0.001);
        let bars2 = create_test_bars(100, 50.0, 0.002);

        engine.add_data("ASSET1", bars1);
        engine.add_data("ASSET2", bars2);
    }

    #[test]
    fn test_multi_asset_backtest() {
        let config = BacktestConfig {
            initial_capital: 100_000.0,
            show_progress: false,
            ..Default::default()
        };

        let mut engine = MultiAssetEngine::new(config);

        let bars1 = create_test_bars(100, 100.0, 0.001);
        let bars2 = create_test_bars(100, 50.0, 0.002);

        engine.add_data("ASSET1", bars1);
        engine.add_data("ASSET2", bars2);

        let mut strategy = EqualWeightStrategy::new(20);
        let result = engine.run(&mut strategy).unwrap();

        assert_eq!(result.symbols.len(), 2);
        assert!(result.final_equity > 0.0);
        assert!(!result.equity_curve.is_empty());
    }
}
